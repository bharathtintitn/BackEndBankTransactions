<?xml version="1.0"?><st-source><methods><class-id>Core.Currency</class-id> <category>initialize-release</category><body package="Assignment5" selector="initialize:">initialize: aObject	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	amount := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\Bharath\Desktop\Assignment5.im' 'February 10, 2014' '7:07:31 PM')""An image file c:\Users\Bharath\Desktop\Assignment5.im was created at 7:07:31 PM on 10 February 2014."</do-it><component-created><name>Assignment6</name> <type>package</type></component-created><class><name>ExchangeRates</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>usdToMxn usdToCad cadToUsd cadToMxn mxnToUsd mxnToCad todayDate </class-inst-vars><imports></imports><category></category><attributes><package>Assignment6</package></attributes></class><class><name>Currency</name><environment>Smalltalk</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>amount currency </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Assignment6</package></attributes></class><class><name>Bank</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>outgoingTransaction accountNumbers bankTransaction </inst-vars><class-inst-vars>routigNumber </class-inst-vars><imports></imports><category></category><attributes><package>Assignment6</package></attributes></class><class><name>BankAccount</name><environment>Smalltalk</environment><super>Bank</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accountNumber accountName customerType availableBalance totalBalance accountDetails </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Assignment6</package></attributes></class><class><name>Transactions</name><environment>Smalltalk</environment><super>Bank</super><private>false</private><indexed-type>none</indexed-type><inst-vars>outgoingTransactions bankAccounts transactionsToExecute </inst-vars><class-inst-vars>transactionId </class-inst-vars><imports></imports><category></category><attributes><package>Assignment6</package></attributes></class><shared-variable><name>routingNumber</name><environment>Bank</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Assignment6</package></attributes></shared-variable><methods><class-id>Bank class</class-id> <category>instance creation</category><body package="Assignment6" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Bank class</class-id> <category>instance creation</category><body package="Assignment6" selector="routingNumber:">routingNumber: aString	"Answer a newly created and initialized instance."	routigNumber := aString.	^super new initialize.</body></methods><methods><class-id>Bank class</class-id> <category>instance creation</category><body package="Assignment6" selector="routigNumber">routigNumber	^routigNumber</body></methods><methods><class-id>ExchangeRates class</class-id> <category>instance creation</category><body package="Assignment6" selector="mxnToCad:">mxnToCad: aObject	mxnToCad := aObject</body></methods><methods><class-id>ExchangeRates class</class-id> <category>instance creation</category><body package="Assignment6" selector="usdToMxn:">usdToMxn: aObject	usdToMxn := aObject</body></methods><methods><class-id>ExchangeRates class</class-id> <category>instance creation</category><body package="Assignment6" selector="mxnToUsd">mxnToUsd	| today |	todayDate ifNil: [todayDate := Date today printFormat: #(2 1 3 $/ 1 1)].	today := Date today printFormat: #(2 1 3 $/ 1 1).	mxnToUsd ifNil: [ExchangeRates readFile].	todayDate &lt; today		ifTrue: 			[ExchangeRates readFile.			todayDate := Date today printFormat: #(2 1 3 $/ 1 1)].	^mxnToUsd</body></methods><methods><class-id>ExchangeRates class</class-id> <category>instance creation</category><body package="Assignment6" selector="mxnToCad">mxnToCad	| today |	todayDate ifNil: [todayDate := Date today printFormat: #(2 1 3 $/ 1 1)].	today := Date today printFormat: #(2 1 3 $/ 1 1).	mxnToCad ifNil: [ExchangeRates readFile].	todayDate &lt; today		ifTrue: 			[ExchangeRates readFile.			todayDate := Date today printFormat: #(2 1 3 $/ 1 1)].	^mxnToCad</body></methods><methods><class-id>ExchangeRates class</class-id> <category>instance creation</category><body package="Assignment6" selector="updateExachangeRatesFromFile:">updateExachangeRatesFromFile: aFilename	| file fileRead line content date rateWithFirstCurrency rateWithSecondCurrency currencyOne currencyTwo bothCurrency endDate currencyAgainstOne currencyAgainstTwo |	file := aFilename asFilename.	currencyOne := Dictionary new.	currencyTwo := Dictionary new.	bothCurrency := OrderedCollection new.	[fileRead := file readStream] on: Error		do: [Error raiseSignal: 'file not found'].	1 to: 4		do: 			[:each |			line := ReadStream on: (fileRead upTo: Character lf).			content := line upTo: $,].	line := ReadStream on: (fileRead upTo: Character lf).	content := line upTo: $,.	endDate := content copyReplaceAll: '"' with: ''.	content := line upTo: $,.	currencyAgainstOne := content copyReplaceAll: '"' with: ''.	content := line upTo: $,.	currencyAgainstTwo := content copyReplaceAll: '"' with: ''.	currencyOne add: endDate -&gt; currencyAgainstOne.	currencyTwo add: endDate -&gt; currencyAgainstTwo.	[content = '""' | fileRead atEnd] whileFalse: 			[line := ReadStream on: (fileRead upTo: Character lf).			content := line upTo: $,.			content = '""'				ifFalse: 					[date := content dateFormat.					content := line upTo: $,.					rateWithFirstCurrency := (content copyReplaceAll: '"' with: '') asNumber.					content := line upTo: $,.					rateWithSecondCurrency := (content copyReplaceAll: '"' with: '') asNumber.					currencyOne add: date -&gt; rateWithFirstCurrency.					currencyTwo add: date -&gt; rateWithSecondCurrency]].	fileRead close.	bothCurrency add: currencyOne.	bothCurrency add: currencyTwo.	^bothCurrency</body></methods><methods><class-id>ExchangeRates class</class-id> <category>instance creation</category><body package="Assignment6" selector="usdToCad">usdToCad	| today |	todayDate ifNil: [todayDate := Date today printFormat: #(2 1 3 $/ 1 1)].	today := Date today printFormat: #(2 1 3 $/ 1 1).	usdToCad ifNil: [ExchangeRates readFile].	todayDate &lt; today		ifTrue: 			[ExchangeRates readFile.			todayDate := Date today printFormat: #(2 1 3 $/ 1 1)].	^usdToCad</body></methods><methods><class-id>ExchangeRates class</class-id> <category>instance creation</category><body package="Assignment6" selector="cadToMxn:">cadToMxn: aObject	cadToMxn := aObject</body></methods><methods><class-id>ExchangeRates class</class-id> <category>instance creation</category><body package="Assignment6" selector="usdToCad:">usdToCad: aObject	usdToCad := aObject</body></methods><methods><class-id>ExchangeRates class</class-id> <category>instance creation</category><body package="Assignment6" selector="readFile">readFile	| currencyPair currencyDetails currencyPairDictionary |	currencyDetails := OrderedCollection new.	currencyDetails := self				updateExachangeRatesFromFile: 'USD.csv'.	currencyPairDictionary := currencyDetails at: 1.	currencyPair := currencyPairDictionary at: 'End Date'.	currencyPair = 'USD/MXN'		ifTrue: 			[ExchangeRates usdToMxn: (currencyDetails at: 1).			ExchangeRates usdToCad: (currencyDetails at: 2)]		ifFalse: 			[ExchangeRates usdToMxn: (currencyDetails at: 2).			ExchangeRates usdToCad: (currencyDetails at: 1)].	currencyDetails := self				updateExachangeRatesFromFile: 'CAD.csv'.	currencyPair := (currencyDetails at: 1) at: 'End Date'.	currencyPair = 'CAD/USD'		ifTrue: 			[ExchangeRates cadToUsd: (currencyDetails at: 1).			ExchangeRates cadToMxn: (currencyDetails at: 2)]		ifFalse: 			[ExchangeRates cadToMxn: (currencyDetails at: 1).			ExchangeRates cadToUsd: (currencyDetails at: 2)].	currencyDetails := self				updateExachangeRatesFromFile: 'MXN.csv'.	currencyPair := (currencyDetails at: 1) at: 'End Date'.	currencyPair = 'MXN/USD'		ifTrue: 			[ExchangeRates mxnToUsd: (currencyDetails at: 1).			ExchangeRates mxnToCad: (currencyDetails at: 2)]		ifFalse: 			[ExchangeRates mxnToCad: (currencyDetails at: 1).			ExchangeRates mxnToUsd: (currencyDetails at: 2)]</body></methods><methods><class-id>ExchangeRates class</class-id> <category>instance creation</category><body package="Assignment6" selector="usdToMxn">usdToMxn	| today |	todayDate ifNil: [todayDate := Date today printFormat: #(2 1 3 $/ 1 1)].	today := Date today printFormat: #(2 1 3 $/ 1 1).	usdToMxn ifNil: [ExchangeRates readFile].	todayDate &lt; today		ifTrue: 			[ExchangeRates readFile.			todayDate := Date today printFormat: #(2 1 3 $/ 1 1)].	^usdToMxn</body></methods><methods><class-id>ExchangeRates class</class-id> <category>instance creation</category><body package="Assignment6" selector="cadToUsd:">cadToUsd: aObject	cadToUsd := aObject</body></methods><methods><class-id>ExchangeRates class</class-id> <category>instance creation</category><body package="Assignment6" selector="cadToUsd">cadToUsd	| today |	todayDate ifNil: [todayDate := Date today printFormat: #(2 1 3 $/ 1 1)].	today := Date today printFormat: #(2 1 3 $/ 1 1).	cadToUsd ifNil: [ExchangeRates readFile].	todayDate &lt; today		ifTrue: 			[ExchangeRates readFile.			todayDate := Date today printFormat: #(2 1 3 $/ 1 1)].	^cadToUsd</body></methods><methods><class-id>ExchangeRates class</class-id> <category>instance creation</category><body package="Assignment6" selector="mxnToUsd:">mxnToUsd: aObject	mxnToUsd := aObject</body></methods><methods><class-id>ExchangeRates class</class-id> <category>instance creation</category><body package="Assignment6" selector="cadToMxn">cadToMxn	| today |	todayDate ifNil: [todayDate := Date today printFormat: #(2 1 3 $/ 1 1)].	today := Date today printFormat: #(2 1 3 $/ 1 1).	cadToMxn ifNil: [ExchangeRates readFile].	todayDate &lt; today		ifTrue: 			[ExchangeRates readFile.			todayDate := Date today printFormat: #(2 1 3 $/ 1 1)].	^cadToMxn</body></methods><methods><class-id>ExchangeRates class</class-id> <category>instance creation</category><body package="Assignment6" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Currency class</class-id> <category>instance creation</category><body package="Assignment6" selector="new:as:">new: aNumber as: aCurrency	"This is parametersied method to created and initialized instance."	^super new initialize: aNumber and: aCurrency</body></methods><methods><class-id>Currency class</class-id> <category>instance creation</category><body package="Assignment6" selector="fromNumber:as:">fromNumber: aNumber as: aCurrency	^(Currency new: aNumber as: aCurrency) beImmutable</body></methods><methods><class-id>Currency class</class-id> <category>instance creation</category><body package="Assignment6" selector="fromString:">fromString: aString	"aNumber := Currency toCheckValidString: aString.	aNumber = 1		ifTrue: [^(Currency new: aString asNumber as: aCurrency) beImmutable]		ifFalse: [self error: 'Error:Does not meet format']"	| aNumber aCurrency splitAmountAndCurrency |	splitAmountAndCurrency := OrderedCollection new.	splitAmountAndCurrency := aString asCurrency.	aNumber := splitAmountAndCurrency at: 1.	aCurrency := splitAmountAndCurrency at: 2.	^(Currency new: aNumber as: aCurrency) beImmutable</body></methods><methods><class-id>Currency class</class-id> <category>instance creation</category><body package="Assignment6" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Currency class</class-id> <category>instance creation</category><body package="Assignment6" selector="toCheckValidString:">toCheckValidString: stringToCheck	"This method checks for numeric string. if string given is numeric. This method returns True, else false."	| stringArray characterValue return asciiOfZero asciiOfNine asciiOfDot asciiOfdash |	return := 0.	stringArray := stringToCheck asArray.	asciiOfZero := $0 asInteger.	asciiOfNine := $9 asInteger.	asciiOfDot := $. asInteger.	asciiOfdash := $- asInteger.	stringArray do: 			[:each |			characterValue := each asCharacter asInteger.			characterValue &gt;= asciiOfZero &amp; (characterValue &lt;= asciiOfNine)				ifFalse: 					[characterValue = asciiOfDot						ifFalse: 							[characterValue = asciiOfdash								ifFalse: 									[return := 0.									^return]]]].	" if string as any other characters then 0-9 &amp; . return false"	return := 1.	^return	" if string as only characters then 0-9 return true"</body></methods><methods><class-id>BankAccount class</class-id> <category>instance creation</category><body package="Assignment6" selector="new:accountName:customerType:amount:at:">new: aAccountNumber accountName: aAccountName customerType: aCustomerType amount: aAmount at: aTimestamp	"Answer a newly created and initialized instance."	^super new initialize: aAccountNumber accountName: aAccountName customerType: aCustomerType amount: aAmount at: aTimestamp.</body></methods><methods><class-id>Transactions class</class-id> <category>instance creation</category><body package="Assignment6" selector="transactionId:">transactionId: aObject	transactionId := aObject.</body></methods><methods><class-id>Transactions class</class-id> <category>instance creation</category><body package="Assignment6" selector="transactionId">transactionId	^transactionId</body></methods><methods><class-id>Bank</class-id> <category>accessing</category><body package="Assignment6" selector="runTransactions">runTransactions	| transaction |	transaction := Transactions new.	transaction executeTransactions: bankTransaction.	self accountNumbers: transaction bankAccounts.	self outgoingTransaction: transaction outgoingTransactions</body></methods><methods><class-id>Bank</class-id> <category>accessing</category><body package="Assignment6" selector="readTransaction:">readTransaction: transactionToUpdate	| detail content count |	detail := OrderedCollection new.	content := ' '.	count := 0.	[content = ''] whileFalse: 			[content := transactionToUpdate upTo: Character tab.			count := count + 1.			count = 2				ifTrue: [content := Timestamp readFromDateAndTime: content readStream].			content = '' ifFalse: [detail add: content]].	detail size &gt; 0 ifTrue: [bankTransaction add: detail].	^bankTransaction</body></methods><methods><class-id>Bank</class-id> <category>accessing</category><body package="Assignment6" selector="sumne">sumne	| temp |	temp := Transactions new.	^temp sampleDelete.</body></methods><methods><class-id>Bank</class-id> <category>accessing</category><body package="Assignment6" selector="transactionsFrom:">transactionsFrom: aFilename	| file fileRead line |	file := aFilename asFilename.	[fileRead := file readStream] on: Error		do: [Error raiseSignal: 'file not found'].	[fileRead atEnd] whileFalse: 			[line := ReadStream on: (fileRead upTo: Character cr).			self readTransaction: line].	self runTransactions.</body></methods><methods><class-id>Bank</class-id> <category>initialize-release</category><body package="Assignment6" selector="initialize:">initialize: aString	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	outgoingTransaction := OrderedCollection new.	accountNumbers := Dictionary new.	bankTransaction := OrderedCollection new.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>Bank</class-id> <category>accessing</category><body package="Assignment6" selector="accountNumbers:">accountNumbers: anObject	accountNumbers := anObject</body></methods><methods><class-id>Bank</class-id> <category>accessing</category><body package="Assignment6" selector="bankTransaction">bankTransaction	^bankTransaction</body></methods><methods><class-id>Bank</class-id> <category>accessing</category><body package="Assignment6" selector="accountNumbers">accountNumbers	^accountNumbers</body></methods><methods><class-id>Bank</class-id> <category>initialize-release</category><body package="Assignment6" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	outgoingTransaction := OrderedCollection new.	accountNumbers := Dictionary new.	bankTransaction := OrderedCollection new.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>Bank</class-id> <category>accessing</category><body package="Assignment6" selector="account:">account: aString	| bankAccount |	bankAccount := self accountNumbers at: aString.	^bankAccount.</body></methods><methods><class-id>Bank</class-id> <category>accessing</category><body package="Assignment6" selector="outgoingTransaction:">outgoingTransaction: anObject	outgoingTransaction := anObject</body></methods><methods><class-id>Bank</class-id> <category>accessing</category><body package="Assignment6" selector="outgoingTransaction">outgoingTransaction	^outgoingTransaction</body></methods><methods><class-id>ExchangeRates</class-id> <category>initialize-release</category><body package="Assignment6" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>Currency</class-id> <category>accessing</category><body package="Assignment6" selector="+">+ aObject	"Yesterdays exachange rate has to be latest exchangeRate to do the transaction, if yesterdays exchange rate is not available, get latest rate"	| date |	date := (Date today) printFormat: #(2 1 3 $/ 1 1).	^self add: aObject at: date</body></methods><methods><class-id>Currency</class-id> <category>accessing</category><body package="Assignment6" selector="currency">currency	^currency</body></methods><methods><class-id>Currency</class-id> <category>accessing</category><body package="Assignment6" selector="convertAmount:of:to:at:">convertAmount: aAmount of: aCurrency to: toCurrency at: date	| conversionDetails exchangeRate finalAmount count |	(aCurrency = 'MXN' &amp; toCurrency) = 'USD'		ifTrue: [conversionDetails := ExchangeRates mxnToUsd].	(aCurrency = 'MXN' &amp; toCurrency) = 'CAD'		ifTrue: [conversionDetails := ExchangeRates mxnToCad].	(aCurrency = 'USD' &amp; toCurrency) = 'CAD'		ifTrue: [conversionDetails := ExchangeRates usdToCad].	(aCurrency = 'USD' &amp; toCurrency) = 'MXN'		ifTrue: [conversionDetails := ExchangeRates usdToMxn].	(aCurrency = 'CAD' &amp; toCurrency) = 'USD'		ifTrue: [conversionDetails := ExchangeRates cadToUsd].	(aCurrency = 'CAD' &amp; toCurrency) = 'MXN'		ifTrue: [conversionDetails := ExchangeRates cadToMxn].	[exchangeRate := conversionDetails at: date] on: Error		do: 			[count := 0.			conversionDetails keysDo: 					[:key |					count := count + 1.					count = 2						ifTrue: 							[finalAmount := aAmount * (conversionDetails at: key) truncateTo: 0.01.							^finalAmount]]].	finalAmount := aAmount * exchangeRate truncateTo: 0.01.	^finalAmount</body></methods><methods><class-id>Currency</class-id> <category>initialize-release</category><body package="Assignment6" selector="initialize:and:">initialize: aNumber and: aCurrency	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	amount := aNumber roundTo: 0.01.	currency := aCurrency.	^self</body></methods><methods><class-id>Currency</class-id> <category>accessing</category><body package="Assignment6" selector="subtract:at:">subtract: aObject at: timestamp	| firstCurrency secondCurrency finalAmount toSubtract difference |	(aObject isKindOf: Currency)		ifTrue: 			[firstCurrency := self currency.			secondCurrency := aObject currency.			firstCurrency = secondCurrency				ifTrue: [toSubtract := aObject amount]				ifFalse: 					[toSubtract := self								convertAmount: aObject amount								of: secondCurrency								to: firstCurrency								at: timestamp]].	finalAmount := self amount - toSubtract.	difference := Currency new: finalAmount as: firstCurrency.	^difference</body></methods><methods><class-id>Currency</class-id> <category>printing</category><body package="Assignment6" selector="printOn:">printOn: aStream	aStream		nextPut: $$;		print: amount;		space;		print: currency</body></methods><methods><class-id>Currency</class-id> <category>accessing</category><body package="Assignment6" selector="readFile:">readFile: aFilename</body></methods><methods><class-id>Currency</class-id> <category>accessing</category><body package="Assignment6" selector="-">- aObject	"Yesterdays exachange rate has to be latest exchangeRate to do the transaction, if yesterdays exchange rate is not available, get latest rate"	| date |	date := (Date today) printFormat: #(2 1 3 $/ 1 1).	^self subtract: aObject at: date</body></methods><methods><class-id>Currency</class-id> <category>accessing</category><body package="Assignment6" selector="amount:">amount: anObject	amount := anObject roundTo: 0.01.</body></methods><methods><class-id>Currency</class-id> <category>comparing</category><body package="Assignment6" selector="=">= aMagnitude	"this method compares amount of two currency objects"	(aMagnitude isKindOf: Currency)		ifTrue: [((self amount = aMagnitude amount) &amp; (self currency = aMagnitude currency)) ifTrue: [^true] ifFalse: [^false]]		ifFalse: [Error raiseSignal: 'Does not meet format']</body></methods><methods><class-id>Currency</class-id> <category>accessing</category><body package="Assignment6" selector="amount">amount	^amount</body></methods><methods><class-id>Currency</class-id> <category>comparing</category><body package="Assignment6" selector="hash">hash	" *** This method was defined by Magnitude as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Currency</class-id> <category>accessing</category><body package="Assignment6" selector="add:at:">add: aObject at: timestamp	| toAdd sum firstCurrency secondCurrency finalAmount |	(aObject isKindOf: Currency)		ifTrue: 			[firstCurrency := self currency.			secondCurrency := aObject currency.			firstCurrency = secondCurrency				ifTrue: [toAdd := aObject amount]				ifFalse: 					[toAdd := self								convertAmount: aObject amount								of: secondCurrency								to: firstCurrency								at: timestamp]]		ifFalse: 			[(aObject isKindOf: Number)				ifTrue: [toAdd := aObject roundTo: 0.01]				ifFalse: [self error: 'Error:Does not meet format']].	finalAmount := toAdd + self amount.	sum := Currency new: finalAmount as: firstCurrency.	^sum</body></methods><methods><class-id>Currency</class-id> <category>accessing</category><body package="Assignment6" selector="currency:">currency: anObject	currency := anObject</body></methods><methods><class-id>Currency</class-id> <category>initialize-release</category><body package="Assignment6" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	amount := nil.	currency := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>Currency</class-id> <category>comparing</category><body package="Assignment6" selector="&lt;">&lt; aMagnitude	(aMagnitude isKindOf: Currency)		ifTrue: 			[self currency = aMagnitude currency				ifTrue: [self amount &lt; aMagnitude amount ifTrue: [^true] ifFalse: [^false]]				ifFalse: [^false]]		ifFalse: [self error: 'Does not meet format']</body></methods><methods><class-id>BankAccount</class-id> <category>accessing</category><body package="Assignment6" selector="balanceUpdate">balanceUpdate	"this method updates total and available balance for availableIn and totalBalanceIn methods."	| length |	length := self accountDetails size.	(self accountDetails at: length) at: 1 put: self totalBalance.	(self accountDetails at: length) at: 2 put: self availableBalance</body></methods><methods><class-id>BankAccount</class-id> <category>accessing</category><body package="Assignment6" selector="getTimestamp">getTimestamp	"this method returns current type of operations on account"	| timestampIndex timestamp dayIs monthIs yearIs dateIs |	timestampIndex := 4.	timestamp := self kindOfOperation: timestampIndex.	dayIs := timestamp day printString.	dayIs size = 1 ifTrue: [dayIs := '0' , dayIs].	monthIs := timestamp month printString.	monthIs size = 1 ifTrue: [monthIs := '0' , monthIs].	yearIs := timestamp year printString.	dateIs := monthIs , '/' , dayIs , '/' , yearIs.	^dateIs</body></methods><methods><class-id>BankAccount</class-id> <category>private</category><body package="Assignment6" selector="accountNumber:">accountNumber: anObject	accountNumber := anObject</body></methods><methods><class-id>BankAccount</class-id> <category>private</category><body package="Assignment6" selector="customerType:">customerType: anObject	customerType := anObject</body></methods><methods><class-id>BankAccount</class-id> <category>private</category><body package="Assignment6" selector="accountNumber">accountNumber	^accountNumber</body></methods><methods><class-id>BankAccount</class-id> <category>accessing</category><body package="Assignment6" selector="availableBalanceUpdateAmount">availableBalanceUpdateAmount	| amountIndex amoutToUpdate timestamp |	amountIndex := 7.	timestamp := self getTimestamp.	amoutToUpdate := self kindOfOperation: amountIndex.	self availableBalance: (self availableBalance				add: (Currency fromString: amoutToUpdate)				at: timestamp)</body></methods><methods><class-id>BankAccount</class-id> <category>accessing</category><body package="Assignment6" selector="availableBalanceCorrection:">availableBalanceCorrection: amountToDeposit	| timestamp |	timestamp := self getTimestamp.	self availableBalance: (self availableBalance				subtract: (Currency fromString: amountToDeposit)				at: timestamp).</body></methods><methods><class-id>BankAccount</class-id> <category>private</category><body package="Assignment6" selector="accountName:">accountName: anObject	accountName := anObject</body></methods><methods><class-id>BankAccount</class-id> <category>accessing</category><body package="Assignment6" selector="balanceTill:for:">balanceTill: timeStamp for: balanceOfType	| balance timeStampIndex |	balance := Currency fromString: '$0.00 USD'.	timeStampIndex := 4.	accountDetails do: 			[:each |			(each at: timeStampIndex) &lt;= timeStamp				ifTrue: [balance := each at: balanceOfType]].	^balance</body></methods><methods><class-id>BankAccount</class-id> <category>accessing</category><body package="Assignment6" selector="withdrawCheck:">withdrawCheck: difference	customerType := self customerType.	customerType = 'Normal' ifTrue: [^0].	customerType = 'Preferred'		ifTrue: [difference &lt; (Currency fromNumber: -1000 as: 'USD') ifTrue: [^0]].	customerType = 'Premium'		ifTrue: [difference &lt; (Currency fromNumber: -10000 as: 'USD') ifTrue: [^0]].	customerType = 'Gold'		ifTrue: [difference &lt; (Currency fromNumber: -100000 as: 'USD') ifTrue: [^0]].	^1</body></methods><methods><class-id>BankAccount</class-id> <category>accessing</category><body package="Assignment6" selector="getDetailsOfTransaction:">getDetailsOfTransaction: transactionDetails	"this method adds availableBalance and totalBalance at starting of transction details. This helps in finding availableBalanceIn and totalBalanceIn"	| tempTransactionDetails length |	tempTransactionDetails := OrderedCollection new.	tempTransactionDetails add: self totalBalance.	tempTransactionDetails add: self availableBalance.	length := transactionDetails size.	1 to: length		do: [:each | tempTransactionDetails add: (transactionDetails at: each)].	self accountDetails add: tempTransactionDetails</body></methods><methods><class-id>BankAccount</class-id> <category>private</category><body package="Assignment6" selector="accountDetails">accountDetails	^accountDetails</body></methods><methods><class-id>BankAccount</class-id> <category>accessing</category><body package="Assignment6" selector="deposit:at:">deposit: anAmount at: timestamp	| depositAmount currentAvailableBalance updateAvailableBalance currentTotalBalance updateTotalBalance |	currentAvailableBalance := self availableBalance.	depositAmount := Currency fromString: anAmount.	updateAvailableBalance := currentAvailableBalance add: depositAmount at: timestamp.	self availableBalance: updateAvailableBalance.		currentTotalBalance := self totalBalance.	updateTotalBalance := currentTotalBalance add: depositAmount at: timestamp.	self totalBalance: updateTotalBalance.		^self.</body></methods><methods><class-id>BankAccount</class-id> <category>private</category><body package="Assignment6" selector="availableBalance:">availableBalance: anObject	availableBalance := anObject</body></methods><methods><class-id>BankAccount</class-id> <category>accessing</category><body package="Assignment6" selector="deposit:">deposit: anAmount	| depositAmount currentAvailableBalance updateAvailableBalance currentTotalBalance updateTotalBalance |	currentAvailableBalance := self availableBalance.	depositAmount := Currency fromString: anAmount.	updateAvailableBalance := currentAvailableBalance + depositAmount.	self availableBalance: updateAvailableBalance.		currentTotalBalance := self totalBalance.	updateTotalBalance := currentTotalBalance + depositAmount.	self totalBalance: updateTotalBalance.		^self.</body></methods><methods><class-id>BankAccount</class-id> <category>initialize-release</category><body package="Assignment6" selector="initialize:accountName:customerType:amount:at:">initialize: aAccountNumber accountName: aAccountName customerType: aCustomerType amount: aAmount at: aTimestamp	super initialize.	accountNumber := aAccountNumber.	accountName := aAccountName.	customerType := aCustomerType.	availableBalance := aAmount.	totalBalance := aAmount.	accountDetails := OrderedCollection new.	self accountDetailsIntialize: aTimestamp.		^self</body></methods><methods><class-id>BankAccount</class-id> <category>accessing</category><body package="Assignment6" selector="bankAccountOperation:">bankAccountOperation: transactionDetails	| typeOfTransaction typeOfTransactionIndex return |	typeOfTransactionIndex := 5.	self getDetailsOfTransaction: transactionDetails.	typeOfTransaction := self kindOfOperation: typeOfTransactionIndex.	typeOfTransaction = 'Deposit' ifTrue: [return := self depositAmount].	typeOfTransaction = 'Withdrawal' ifTrue: [return := self withdrawAmount].	typeOfTransaction = 'Cancel' ifTrue: [return := self cancelAmount].	typeOfTransaction = 'AvailableBalance'		ifTrue: [return := self availableBalanceUpdateAmount].	self balanceUpdate.	^return</body></methods><methods><class-id>BankAccount</class-id> <category>private</category><body package="Assignment6" selector="accountDetails:">accountDetails: anObject	accountDetails := anObject</body></methods><methods><class-id>BankAccount</class-id> <category>accessing</category><body package="Assignment6" selector="cancelAmount">cancelAmount	| transactionIdIndex amountIndex getTransactionIdToCancel amount getAmountToSubtract typeOfTransaction transactionNumberAt |	transactionIdIndex := 7.	transactionNumberAt := 3.	amountIndex := 11.	typeOfTransaction := 5.	getTransactionIdToCancel := self kindOfOperation: transactionIdIndex.	2 to: accountDetails size		do: 			[:index |			getTransactionIdToCancel				= ((accountDetails at: index) at: transactionNumberAt)					ifTrue: 						[((accountDetails at: index) at: typeOfTransaction) = 'Deposit'							ifTrue: 								[amount := (accountDetails at: index) at: amountIndex.								getAmountToSubtract := Currency fromString: amount.								self totalBalanceCorrection: getAmountToSubtract at: index.]]]</body></methods><methods><class-id>BankAccount</class-id> <category>private</category><body package="Assignment6" selector="totalBalance">totalBalance	^totalBalance</body></methods><methods><class-id>BankAccount</class-id> <category>private</category><body package="Assignment6" selector="totalBalance:">totalBalance: anObject	totalBalance := anObject</body></methods><methods><class-id>BankAccount</class-id> <category>private</category><body package="Assignment6" selector="customerType">customerType	^customerType</body></methods><methods><class-id>BankAccount</class-id> <category>accessing</category><body package="Assignment6" selector="totalBalanceCorrection:at:">totalBalanceCorrection: amount at: index	| timestamp timestampIndex dayIs monthIs yearIs dateIs |	timestampIndex := 4.	timestamp := (self accountDetails at: index) at: timestampIndex.	dayIs := timestamp day printString.	dayIs size = 1 ifTrue: [dayIs := '0' , dayIs].	monthIs := timestamp month printString.	monthIs size = 1 ifTrue: [monthIs := '0' , monthIs].	yearIs := timestamp year printString.	dateIs := monthIs , '/' , dayIs , '/' , yearIs.	self totalBalance: (self totalBalance subtract: amount at: dateIs)</body></methods><methods><class-id>BankAccount</class-id> <category>private</category><body package="Assignment6" selector="availableBalance">availableBalance	^availableBalance</body></methods><methods><class-id>BankAccount</class-id> <category>accessing</category><body package="Assignment6" selector="kindOfOperation:">kindOfOperation: atIndex	"this method returns current type of operations on account"	| length typeOfOperationIndex typeOfOperation |	length := self accountDetails size.	typeOfOperationIndex := atIndex.	typeOfOperation := (self accountDetails at: length)				at: typeOfOperationIndex.	^typeOfOperation</body></methods><methods><class-id>BankAccount</class-id> <category>private</category><body package="Assignment6" selector="accountName">accountName	^accountName</body></methods><methods><class-id>BankAccount</class-id> <category>accessing</category><body package="Assignment6" selector="withdrawAmount">withdrawAmount	| withdrawModeIndex withdrawMode amountToWithdrawIndex amountToWithdraw return timestampIndex timestamp |	withdrawModeIndex := 6.	timestamp := self getTimestamp.	withdrawMode := self kindOfOperation: withdrawModeIndex.	withdrawMode = 'Cash'		ifTrue: 			[amountToWithdrawIndex := 8.			amountToWithdraw := self kindOfOperation: amountToWithdrawIndex.			return := self withdrawal: amountToWithdraw at: timestamp].	withdrawMode = 'Check'		ifTrue: 			[amountToWithdrawIndex := 10.			amountToWithdraw := self kindOfOperation: amountToWithdrawIndex.			return := self withdrawal: amountToWithdraw at: timestamp].	^return</body></methods><methods><class-id>BankAccount</class-id> <category>accessing</category><body package="Assignment6" selector="accountDetailsIntialize:">accountDetailsIntialize: aTimestamp	| tempTransactionDetails |	tempTransactionDetails := OrderedCollection new.	tempTransactionDetails add: self totalBalance.	tempTransactionDetails add: self availableBalance.	tempTransactionDetails add: 'dummy'.	tempTransactionDetails add: aTimestamp.	self accountDetails add: tempTransactionDetails</body></methods><methods><class-id>BankAccount</class-id> <category>accessing</category><body package="Assignment6" selector="withdrawal:at:">withdrawal: anAmount at: timestamp	| withdrawAmount currentAvailableBalance currentTotalBalance updateAvailableBalance updateTotalBalance difference return canWithdrawPerform |	return := 1.	currentAvailableBalance := self availableBalance.	currentTotalBalance := self totalBalance.	withdrawAmount := Currency fromString: anAmount.	difference := currentAvailableBalance subtract: withdrawAmount at: timestamp.	difference &lt; (Currency fromString: '$0.00 USD')		ifTrue: 			[canWithdrawPerform := self withdrawCheck: difference.			canWithdrawPerform = 1				ifTrue: [withdrawAmount := withdrawAmount]				ifFalse: 					[return := 0.					withdrawAmount := self withdrawPenalty]].	updateAvailableBalance := currentAvailableBalance  subtract: withdrawAmount at: timestamp.	updateTotalBalance := currentTotalBalance subtract: withdrawAmount at: timestamp.	self availableBalance: updateAvailableBalance.	self totalBalance: updateTotalBalance.	^return.</body></methods><methods><class-id>BankAccount</class-id> <category>accessing</category><body package="Assignment6" selector="availableBalanceIn:">availableBalanceIn: aDuration	| availableBalanceIndex tillTimeStamp amount |	availableBalanceIndex := 2.	tillTimeStamp := Timestamp now + aDuration.	amount := self balanceTill: tillTimeStamp for: availableBalanceIndex.	^amount</body></methods><methods><class-id>BankAccount</class-id> <category>accessing</category><body package="Assignment6" selector="withdrawPenalty">withdrawPenalty	customerType := self customerType.	customerType = 'Normal' ifTrue: [^Currency fromString: '$5.00 USD'].	customerType = 'Preferred' ifTrue: [^Currency fromString: '$3.00 USD'].	customerType = 'Premium' ifTrue: [^Currency fromString: '$700.00 USD'].	customerType = 'Gold' ifTrue: [^Currency fromString: '$5000.00 USD']</body></methods><methods><class-id>BankAccount</class-id> <category>accessing</category><body package="Assignment6" selector="balanceIn:">balanceIn: aDuration	| tillTimeStamp amount balanceIndex |	balanceIndex := 1.	tillTimeStamp := Timestamp now + aDuration.	amount := self balanceTill: tillTimeStamp for: balanceIndex.	^amount</body></methods><methods><class-id>BankAccount</class-id> <category>accessing</category><body package="Assignment6" selector="depositAmount">depositAmount	| depositModeIndex depositMode amountToDepositIndex amountToDeposit timestamp |	depositModeIndex := 6.	depositMode := self kindOfOperation: depositModeIndex.	timestamp := self getTimestamp.	depositMode = 'Cash'		ifTrue: 			[amountToDepositIndex := 8.			amountToDeposit := self kindOfOperation: amountToDepositIndex.			self deposit: amountToDeposit at: timestamp].		depositMode = 'Check'		ifTrue: 			[amountToDepositIndex := 11.			amountToDeposit := self kindOfOperation: amountToDepositIndex.			self deposit: amountToDeposit at: timestamp.			self availableBalanceCorrection: amountToDeposit.			].</body></methods><methods><class-id>Transactions</class-id> <category>accessing</category><body package="Assignment6" selector="depositAmount:">depositAmount: transaction	"this method get a account number for which transaction to occur"	| bankAccount depositTypeIndex depositType depositAccountIndex accountNumberIndex |	depositTypeIndex := 4.	accountNumberIndex := 2.	depositType := transaction at: depositTypeIndex.	depositType = 'Cash'		ifTrue: 			[depositAccountIndex := 5.			bankAccount := self bankAccounts						at: ((self operationOnaccount: depositAccountIndex for: transaction)								at: accountNumberIndex).			bankAccount bankAccountOperation: transaction].	depositType = 'Check'		ifTrue: 			[depositAccountIndex := 6.			bankAccount := self bankAccounts						at: ((self operationOnaccount: depositAccountIndex for: transaction)								at: accountNumberIndex).			bankAccount bankAccountOperation: transaction.			self generateWithdrawalTransaction: transaction.			self generateAvailableBalance: transaction]</body></methods><methods><class-id>Transactions</class-id> <category>accessing</category><body package="Assignment6" selector="sampleDelete">sampleDelete^self routingNumber.</body></methods><methods><class-id>Transactions</class-id> <category>accessing</category><body package="Assignment6" selector="withdrawalAmount:">withdrawalAmount: transaction	"this method withdraws amount from particular account"	| bankAccount result accountNumberIndex withdrawTypeIndex withdrawType withdrawAccountIndex |	withdrawTypeIndex := 4.	accountNumberIndex := 2.	withdrawType := transaction at: withdrawTypeIndex.	withdrawType = 'Cash'		ifTrue: 			[withdrawAccountIndex := 5.			bankAccount := self bankAccounts						at: ((self operationOnaccount: withdrawAccountIndex for: transaction)								at: accountNumberIndex).			result := bankAccount bankAccountOperation: transaction].	withdrawType = 'Check'		ifTrue: 			[withdrawAccountIndex := 5.			bankAccount := self bankAccounts						at: ((self operationOnaccount: withdrawAccountIndex for: transaction)								at: accountNumberIndex).			result := bankAccount bankAccountOperation: transaction.			result = 0				ifTrue: [self generateCancelTransaction: transaction]				"ifFalse: 					[9 = transaction size ifTrue: [self generateUpdateBalance: transaction]]"]</body></methods><methods><class-id>Transactions</class-id> <category>accessing</category><body package="Assignment6" selector="checkToBegenerated:">checkToBegenerated: transaction	| routingNumberOfAccountIndex routingNumberOfAccount routingNumberIndex |	routingNumberOfAccountIndex := 5.	routingNumberIndex := 1.	routingNumberOfAccount := (self				operationOnaccount: routingNumberOfAccountIndex				for: transaction) at: routingNumberIndex.	routingNumberOfAccount = Bank routigNumber				ifFalse: 					[^0].^1.</body></methods><methods><class-id>Transactions</class-id> <category>private</category><body package="Assignment6" selector="transactionsToExecute:">transactionsToExecute: aObject	transactionsToExecute := aObject</body></methods><methods><class-id>Transactions</class-id> <category>accessing</category><body package="Assignment6" selector="executeTransactions:">executeTransactions: transactionDetails	Transactions transactionId: 1000.	self transactionsToExecute: (self sortTransaction: transactionDetails).	self performOperations</body></methods><methods><class-id>Transactions</class-id> <category>accessing</category><body package="Assignment6" selector="sortTransaction:">sortTransaction: inCollection	"we will sort all customer transactions using bubble sort, according to respective timestamp."	| numberOfTransaction timeStampOfIndexJ timeStampOfIndexJplus1 temp bankTransactions |	bankTransactions := inCollection.	numberOfTransaction := bankTransactions size.	1 to: numberOfTransaction		do: 			[:each |			1 to: numberOfTransaction - each				do: 					[:index |					timeStampOfIndexJ := (bankTransactions at: index) at: 2.					timeStampOfIndexJplus1 := (bankTransactions at: index + 1) at: 2.					timeStampOfIndexJ &gt; timeStampOfIndexJplus1						ifTrue: 							[temp := bankTransactions at: index.							bankTransactions at: index put: (bankTransactions at: index + 1).							bankTransactions at: index + 1 put: temp]]].	^bankTransactions</body></methods><methods><class-id>Transactions</class-id> <category>accessing</category><body package="Assignment6" selector="generateUpdateBalance:">generateUpdateBalance: transaction	"In this function we create new available balance update transaction."	| transactionIdForWithdrawal timestampIndex toAccountIndex amountIndex timestamp toAccount amountToWithdraw availableInput |	transactionIdForWithdrawal := Transactions transactionId.	Transactions transactionId: transactionIdForWithdrawal + 1.	timestampIndex := 2.	toAccountIndex := 6.	amountIndex := 8.	timestamp := (transaction at: timestampIndex) + 2 minutes.	toAccount := transaction at: toAccountIndex.	amountToWithdraw := transaction at: amountIndex.	availableInput := OrderedCollection new.	availableInput add: (transactionIdForWithdrawal) printString.	availableInput add: timestamp.	availableInput add: 'AvailableBalance'.	availableInput add: toAccount.	availableInput add: amountToWithdraw.	availableInput add: 'Create'.	self transactionsToExecuteAdd: availableInput</body></methods><methods><class-id>Transactions</class-id> <category>private</category><body package="Assignment6" selector="outgoingTransactions:">outgoingTransactions: anObject	outgoingTransactions add: anObject</body></methods><methods><class-id>Transactions</class-id> <category>accessing</category><body package="Assignment6" selector="operationOnaccount:for:">operationOnaccount: accountNumberIndex for: transaction	"This method returns account number and routing number on which current transaction will occur."	| routingAccountNumber numberSeparated |	routingAccountNumber := transaction at: accountNumberIndex.	numberSeparated := routingAccountNumber				separateAccountNumberAndRoutingNumber.	^numberSeparated</body></methods><methods><class-id>Transactions</class-id> <category>accessing</category><body package="Assignment6" selector="availableBalanaceUpdate:">availableBalanaceUpdate: transaction	| accountNumberIndex availableBalanceAccountIndex bankAccount |	accountNumberIndex := 2.	availableBalanceAccountIndex := 4.	bankAccount := self bankAccounts						at: ((self operationOnaccount: availableBalanceAccountIndex for: transaction)								at: accountNumberIndex).			bankAccount bankAccountOperation: transaction.</body></methods><methods><class-id>Transactions</class-id> <category>private</category><body package="Assignment6" selector="bankAccounts">bankAccounts	^bankAccounts</body></methods><methods><class-id>Transactions</class-id> <category>accessing</category><body package="Assignment6" selector="generateCancelTransaction:">generateCancelTransaction: transaction	"In this function we create cancel transaction."	| timestampIndex toAccountIndex timestamp typeOfTransaction toAccount transactionIdForCancel transactionIdToCancelIndex transactionIdToCancel cancelInput |	transactionIdForCancel := Transactions transactionId.	Transactions transactionId: transactionIdForCancel + 1.	timestampIndex := 2.	transactionIdToCancelIndex := 1.	toAccountIndex := 6.	timestamp := (transaction at: timestampIndex).	typeOfTransaction := 'Cancel'.	toAccount := transaction at: toAccountIndex.	transactionIdToCancel := transaction at: transactionIdToCancelIndex.	cancelInput := OrderedCollection new.	cancelInput add: (transactionIdForCancel) printString.	cancelInput add: timestamp + 1 minutes.	cancelInput add: typeOfTransaction.	cancelInput add: toAccount.	cancelInput add: transactionIdToCancel.	cancelInput add: 'Create'.	self transactionsToExecuteAdd: cancelInput</body></methods><methods><class-id>Transactions</class-id> <category>accessing</category><body package="Assignment6" selector="createAccount:">createAccount: transaction	"this method create a new account from the transaction details sent from user"	| accountNameIndex accountType accountTypeIndex accountIntialBalanceIndex accountBalance accountNumberIndex accountName accountNumber bankAccount timestampIndex |	accountNumberIndex := 4.	accountNameIndex := 5.	accountTypeIndex := 6.	accountIntialBalanceIndex := 7.	timestampIndex := 2.	accountNumber := transaction at: accountNumberIndex.	accountName := transaction at: accountNameIndex.	accountType := transaction at: accountTypeIndex.	accountBalance := Currency				fromString: (transaction at: accountIntialBalanceIndex).	bankAccount := BankAccount				new: accountNumber				accountName: accountName				customerType: accountType				amount: accountBalance				at: (transaction at: timestampIndex).	self bankAccounts add: accountNumber -&gt; bankAccount</body></methods><methods><class-id>Transactions</class-id> <category>initialize-release</category><body package="Assignment6" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	outgoingTransactions := OrderedCollection new.	bankAccounts := Dictionary new.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>Transactions</class-id> <category>accessing</category><body package="Assignment6" selector="isToBeIncluded:">isToBeIncluded: transaction	| withdrawAccountIndex typeOfTransaction routingNumberForComparsion |	typeOfTransaction := transaction at: 3.	withdrawAccountIndex := 0.	typeOfTransaction = 'Withdrawal' ifTrue: [withdrawAccountIndex := 5].	typeOfTransaction = 'Cancel' ifTrue: [withdrawAccountIndex := 4].	withdrawAccountIndex = 0		ifFalse: 			[routingNumberForComparsion := (self						operationOnaccount: withdrawAccountIndex						for: transaction) at: 1.			routingNumberForComparsion = Bank routigNumber				ifFalse: 					[self outgoingTransactions: transaction.					^0]].	^1</body></methods><methods><class-id>Transactions</class-id> <category>accessing</category><body package="Assignment6" selector="transactionsToExecuteAdd:">transactionsToExecuteAdd: newTransaction	| toInclude |	toInclude := self isToBeIncluded: newTransaction.	toInclude = 1		ifTrue: 			[self transactionsToExecute add: newTransaction.			self sortTransaction: (self transactionsToExecute)]</body></methods><methods><class-id>Transactions</class-id> <category>accessing</category><body package="Assignment6" selector="generateAvailableBalance:">generateAvailableBalance: transaction	"In this function we create new availbale balance update transaction."	"toGenerate := self checkToBegenerated: transaction.	(toGenerate = 1) ifTrue:[^self]."	| toAccountIndex amountIndex transactionId availableInput |	transactionId := 1.	toAccountIndex := 6.	amountIndex := 9.	availableInput := OrderedCollection new.	availableInput add: (transaction at: transactionId).	availableInput add: (self getTimeStampFor: transaction).	availableInput add: 'AvailableBalance'.	availableInput add: (transaction at: toAccountIndex).	availableInput add: (transaction at: amountIndex).	availableInput add: 'Create'.	self transactionsToExecuteAdd: availableInput</body></methods><methods><class-id>Transactions</class-id> <category>accessing</category><body package="Assignment6" selector="performOperations">performOperations	"here we perform all the operations given in file in ascending order"	| numberOfTransaction count transaction operationToPerform |	numberOfTransaction := self transactionsToExecute size.	count := 1.	[count &lt;= numberOfTransaction] whileTrue: 			[transaction := self transactionsToExecute at: count.			operationToPerform := transaction at: 3.			operationToPerform = 'NewAccount'				ifTrue: [self createAccount: transaction].			operationToPerform = 'Deposit' ifTrue: [self depositAmount: transaction].			operationToPerform = 'Withdrawal'				ifTrue: [self withdrawalAmount: transaction].			operationToPerform = 'Cancel' ifTrue: [self cancelCheck: transaction].			operationToPerform = 'AvailableBalance'				ifTrue: [self availableBalanaceUpdate: transaction].			count := count + 1.			numberOfTransaction := self transactionsToExecute size]</body></methods><methods><class-id>Transactions</class-id> <category>private</category><body package="Assignment6" selector="bankAccounts:">bankAccounts: anObject	bankAccounts := anObject</body></methods><methods><class-id>Transactions</class-id> <category>accessing</category><body package="Assignment6" selector="generateWithdrawalTransaction:">generateWithdrawalTransaction: transaction	"In this function we create new withdraw transaction."	| transactionIdForWithdrawal timestampIndex fromAccountIndex toAccountIndex amountIndex withdrawalInput transactionIdIndex |	transactionIdForWithdrawal := Transactions transactionId.	Transactions transactionId: transactionIdForWithdrawal + 1.	transactionIdIndex := 1.	timestampIndex := 2.	fromAccountIndex := 5.	toAccountIndex := 6.	amountIndex := 9.	withdrawalInput := OrderedCollection new.	withdrawalInput add: (transaction at: transactionIdIndex).	withdrawalInput add: (transaction at: timestampIndex) + 2 minutes.	withdrawalInput add: 'Withdrawal'.	withdrawalInput add: 'Check'.	withdrawalInput add: (transaction at: fromAccountIndex).	withdrawalInput add: (transaction at: toAccountIndex).	withdrawalInput add: transactionIdForWithdrawal - 500.	withdrawalInput add: (transaction at: amountIndex).	withdrawalInput add: 'Create'.	self transactionsToExecuteAdd: withdrawalInput</body></methods><methods><class-id>Transactions</class-id> <category>private</category><body package="Assignment6" selector="transactionsToExecute">transactionsToExecute	^transactionsToExecute</body></methods><methods><class-id>Transactions</class-id> <category>accessing</category><body package="Assignment6" selector="cancelCheck:">cancelCheck: transaction	"this method cancels previous deposit for particular account"	| bankAccount accountNumberIndex transactionIdIndex getTransactionIdToCancel cancelAccountIndex count length return |	transactionIdIndex := 5.	getTransactionIdToCancel := transaction at: transactionIdIndex.	cancelAccountIndex := 4.	accountNumberIndex := 2.	count := 1.	return := 0.	length := self transactionsToExecute size.	[count &lt;= length] whileTrue: 			[getTransactionIdToCancel = ((self transactionsToExecute at: count) at: 1)				ifTrue: 					['AvailableBalance' = ((self transactionsToExecute at: count) at: 3)						ifTrue: 							[self transactionsToExecute remove: (self transactionsToExecute at: count).							bankAccount := self bankAccounts										at: ((self operationOnaccount: cancelAccountIndex for: transaction)												at: accountNumberIndex).							bankAccount bankAccountOperation: transaction.							^(return := 1)]].			length := self transactionsToExecute size.			count := count + 1].	^return</body></methods><methods><class-id>Transactions</class-id> <category>accessing</category><body package="Assignment6" selector="getTimeStampFor:">getTimeStampFor: transaction	| accountNumberIndex timestampIndex holdIndex routingNumberIndex routingNumberToCheck timestamp |	accountNumberIndex := 5.	timestampIndex := 2.	holdIndex := 8.	routingNumberIndex := 1.	routingNumberToCheck := (self operationOnaccount: accountNumberIndex				for: transaction) at: routingNumberIndex.	routingNumberToCheck ~= Bank routigNumber		ifTrue: 			[timestamp := (transaction at: timestampIndex)						+ (transaction at: holdIndex) asNumber days]		ifFalse: [timestamp := (transaction at: timestampIndex) + 4 minutes].	^timestamp</body></methods><methods><class-id>Transactions</class-id> <category>accessing</category><body package="Assignment6" selector="routingNumber">routingNumber	^super routingNumber.</body></methods><methods><class-id>Transactions</class-id> <category>private</category><body package="Assignment6" selector="outgoingTransactions">outgoingTransactions	^outgoingTransactions</body></methods><methods><class-id>Core.String</class-id> <category>accessing</category><body package="Assignment6" selector="asNumber:">asNumber: aString	| result |	result := String new.	result := aString copyReplaceAll:'$' with: ''.	^result asNumber.</body></methods><methods><class-id>Core.String</class-id> <category>accessing</category><body package="Assignment6" selector="asCurrency">asCurrency	| aStream amount typeOfCurrency amountCurrency |	aStream := ReadStream on: self.	aStream upTo: $$.	amount := (aStream upTo: Character space) asNumber.	typeOfCurrency := aStream upToEnd.	amountCurrency := OrderedCollection new.	amountCurrency add: amount.	amountCurrency add: typeOfCurrency.	^amountCurrency</body></methods><methods><class-id>Core.String</class-id> <category>accessing</category><body package="Assignment6" selector="separateAccountNumberAndRoutingNumber">separateAccountNumberAndRoutingNumber	| aStream routingNumber accountNumber bankAccountNumber |	aStream := ReadStream on: self.	aStream upTo: $:.	routingNumber := aStream upTo: $:.	accountNumber := aStream upToEnd.	bankAccountNumber := OrderedCollection new.	bankAccountNumber add: routingNumber.	bankAccountNumber add: accountNumber.	^bankAccountNumber</body></methods><methods><class-id>Core.String</class-id> <category>accessing</category><body package="Assignment6" selector="dateFormat">dateFormat	| separator monthIndex dayIndex yearIndex data date |	separator := '/'.	monthIndex := 2.	dayIndex := 3.	yearIndex := 1.	data := (self copyReplaceAll: '"' with: '') tokensBasedOn: $-.	date := (data at: monthIndex) , separator , (data at: dayIndex)				, separator , (data at: yearIndex).	^date</body></methods><pundle-loaded><name>Assignment6</name><type>package</type><primaryKey>12</primaryKey><databaseId>#bharathmylarappa</databaseId></pundle-loaded><component-rename><name>Assignment6</name> <type>package</type><newName>BankAccount</newName></component-rename><component-property><name>BankAccount</name> <type>package</type><property>packageName</property> <value>'BankAccount'</value></component-property><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\Bharath\Desktop\Assignment5.im' 'June 17, 2014' '12:50:02 AM')""An image file c:\Users\Bharath\Desktop\Assignment5.im was created at 12:50:02 AM on 17 June 2014."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('c:\Users\Bharath\Desktop\Assignment5.im' 'June 17, 2014' '12:52:24 AM')""An image file c:\Users\Bharath\Desktop\Assignment5.im was created at 12:52:24 AM on 17 June 2014."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('f:\oops\BankTransactions.im' 'June 17, 2014' '12:52:54 AM')""An image file f:\oops\BankTransactions.im was created at 12:52:54 AM on 17 June 2014."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('f:\oops\BankTransactions.im' 'June 17, 2014' '12:56:10 AM')""An image file f:\oops\BankTransactions.im was created at 12:56:10 AM on 17 June 2014."</do-it>